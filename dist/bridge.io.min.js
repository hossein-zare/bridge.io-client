class Crypto{static Key='!@#v/$&@$^#$%!WREs1grHWGeAS5DS'
static encrypt(data){return CryptoJS.AES.encrypt(data,Crypto.Key).toString()}
static decrypt(data){const bytes=CryptoJS.AES.decrypt(data,Crypto.Key);return bytes.toString(CryptoJS.enc.Utf8)}}
export default class BridgeIO{constructor(server,config={}){this.server=server;this.config=Object.assign({protocol:[],attempts:null,timeout:2000},config);this.connection=null;this.opened=!1;this.attempts=0;this.disconnected=!1;this.dontFireCloseEvent=!1;this.casterId=400;this.acknowledgments={};this.events={open:()=>{},connection_ready:()=>{},close:()=>{},reconnecting:()=>{},reconnected:()=>{},}}
isObject(o){return o instanceof Object&&o.constructor===Object}
defaultEvents(){this.connection.addEventListener('open',(...args)=>{if(!this.opened){this.events.open(...args);this.opened=!0}else{this.events.reconnected(...args)}
this.attempts=0;this.heartbeat()});this.connection.addEventListener('close',(e)=>{clearTimeout(this.connection.pingTimeout);if(!this.dontFireCloseEvent)
this.events.close(e);else this.dontFireCloseEvent=!1;if(!e.wasClean&&(this.config.attempts===null||this.attempts<this.config.attempts)){setTimeout(()=>this.reconnect(!0),this.config.timeout)}});this.connection.addEventListener('message',(e)=>{if(e.data==='9'){this.connection.send(10);this.heartbeat()}else{const decrypted=Crypto.decrypt(e.data);const json=JSON.parse(decrypted)
const{event=null,data=null}=json;if(event==='ack'&&this.isObject(data)&&data.ack&&Array.isArray(data.args)){if(data.ack in this.acknowledgments){this.acknowledgments[data.ack](...data.args);delete this.acknowledgments[data.ack]}}else if(event==='ready'){this.events.connection_ready(this.opened)}else if(event in this.events){this.events[event](data)}}})}
connect(){if(this.connection){if(this.connection.readyState===1)
return;this.disconnect()}
this.connection=new WebSocket(this.server,this.config.protocol);this.defaultEvents();this.attempts++;this.disconnected=!1}
reconnect(preserveAttempts=!1){if(this.disconnected)
return;if(!preserveAttempts)
this.attempts=0;this.events.reconnecting();this.connect()}
heartbeat(){clearTimeout(this.connection.pingTimeout);this.connection.pingTimeout=setTimeout(()=>{this.connection.close();this.connect()},30000+1000)}
on(event,callback){if(['error'].includes(event)){this.connection.addEventListener(event,callback)}
this.events[event]=callback}
cast(event,data,acknowledgment=null){const message={event,data,};if(acknowledgment){message.ack=this.casterId;this.acknowledgments[this.casterId]=acknowledgment;this.casterId++}
const json=JSON.stringify(message);const encrypted=Crypto.encrypt(json);this.connection.send(encrypted)}
disconnect(){if(!this.connection)
return;clearTimeout(this.connection.pingTimeout);this.connection.close();this.connection=null;this.disconnected=!0}}