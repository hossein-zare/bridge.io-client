class EventEmitter{constructor(){this.events={}}on(t,e){this.events[t]||(this.events[t]=e)}emit(t,...e){this.events[t]&&this.events[t](...e)}}class BridgeIO extends EventEmitter{constructor(t){super(),this.opt=Object.assign({server:"ws://localhost",protocols:[],response_timeout:5e3,attempts:null,delay:2e3,reconnection:!0},t),this.socket=null,this.rpcId=0,this.callbacks={},this.rpcTimeouts={},this.reconnectionAttempts=0,this.reconnectionInterval=null,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),this.connect()}connect(){(null===this.socket||this.socket.readyState>2)&&(this.socket=null,this.socket=new WebSocket(this.opt.server,this.opt.protocols),this.socket.binaryType="arraybuffer",this.socketEvents(),clearInterval(this.reconnectionInterval))}socketEvents(){this.socket.onopen=(t=>{const e=this.reconnectionAttempts>0;this.emit("open",t,e)}),this.socket.onerror=(t=>{this.emit("error",t)}),this.socket.onclose=(t=>{this.emit("disconnected",t),!t.wasClean&&this.opt.reconnection&&(this.reconnectionInterval=setInterval(()=>{this.reconnectionAttempts++,null===this.opt.attempts||this.reconnectionAttempts<=this.opt.attempts?(this.emit("reconnecting",t),this.connect()):clearInterval(this.reconnectionInterval)},this.opt.delay))}),this.socket.onmessage=(t=>{const{data:e}=t;if(this.isReadyFlag(e)){const e=this.reconnectionAttempts>0;this.emit("connection",t,e),e&&this.emit("reconnection",t),this.reconnectionAttempts=0}else if(this.isPong(e))this.ping();else try{this.message(e)}catch(t){console.warn(t)}})}message(t){t=this.toString(t),t=atob(t),t=JSON.parse(t);const[e,s,n]=t;if("string"==typeof e)switch(e){case"rpc":this.rpc(t);break;default:this.emit(e,s)}}rpc(t){const[e,s,n]=t;this.callbacks[n]&&(this.callbacks[n](s),clearTimeout(this.rpcTimeouts[n]))}serializeMessage(t,e,s){let n=[t,e,s];return n=JSON.stringify(n),n=btoa(n),n=this.toBuffer(n)}cast(t,e=null,s=null){let n;s&&(n=++this.rpcId,this.callbacks[n]=s,this.rpcTimeouts[n]=setTimeout(()=>{delete this.callbacks[n]},this.opt.response_timeout));const i=this.serializeMessage(t,e,n);this.socket.send(i)}isReadyFlag(t){return 11===Number(t)}isPong(t){return 10===Number(t)}ping(){this.socket.send(this.isReactNative?"9":9)}toString(t){return String.fromCharCode.apply(null,new Uint16Array(t))}toBuffer(t){const e=t.length,s=new ArrayBuffer(2*e);let n=new Uint16Array(s);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return s}}