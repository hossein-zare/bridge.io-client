class EventEmitter{constructor(){this.events={}}on(t,e){this.events[t]||(this.events[t]=e)}emit(t,...e){this.events[t]&&this.events[t](...e)}}class BridgeIO extends EventEmitter{constructor(t){super(),this.opt=Object.assign({server:"ws://localhost",protocols:[],response_timeout:5e3,attempts:null,delay:2e3,reconnection:!0},t),this.socket=null,this.rpcId=0,this.responseCallbacks={},this.errorCallbacks={},this.rpcTimeouts={},this.reconnectionAttempts=0,this.reconnectionInterval=null,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),this.connect()}connect(){(null===this.socket||this.socket.readyState>2)&&(this.socket=null,this.socket=new WebSocket(this.opt.server,this.opt.protocols),this.socket.binaryType="arraybuffer",this.socketEvents(),clearInterval(this.reconnectionInterval))}socketEvents(){this.socket.onopen=(t=>{const e=this.reconnectionAttempts>0;this.emit("open",t,e)}),this.socket.onerror=(t=>{this.emit("error",t)}),this.socket.onclose=(t=>{this.emit("disconnected",t),!t.wasClean&&this.opt.reconnection&&(this.reconnectionInterval=setInterval(()=>{this.reconnectionAttempts++,null===this.opt.attempts||this.reconnectionAttempts<=this.opt.attempts?(this.emit("reconnecting",t),this.connect()):clearInterval(this.reconnectionInterval)},this.opt.delay))}),this.socket.onmessage=(t=>{const{data:e}=t;if(this.isReadyFlag(e)){const e=this.reconnectionAttempts>0;this.emit("connection",t,e),e&&this.emit("reconnection",t),this.reconnectionAttempts=0}else if(this.isPong(e))this.ping();else try{this.message(e)}catch(t){console.warn(t)}})}message(t){t=this.toString(t),t=atob(t),t=JSON.parse(t);const[e,s,i]=t;if("string"==typeof e)switch(e){case"rpc":this.rpc(t);break;default:this.emit(e,s)}}rpc(t){const[e,s,i]=t;"[object Object]"===Object.prototype.toString.call(s)&&s.hasOwnProperty("status")&&Number.isInteger(s.status)&&s.status>=400?this.errorCallbacks[i]&&this.errorCallbacks[i](s):this.responseCallbacks[i]&&this.responseCallbacks[i](s),this.responseCallbacks[i]&&delete this.responseCallbacks[i],this.errorCallbacks[i]&&delete this.errorCallbacks[i],clearTimeout(this.rpcTimeouts[i])}serializeMessage(t,e,s){let i=[t,e,s];return i=JSON.stringify(i),i=btoa(i),i=this.toBuffer(i)}cast(t,e=null,s=null,i=null,n={}){let r;n=Object.assign({timeout:this.opt.response_timeout},n),s&&(r=++this.rpcId,this.responseCallbacks[r]=s,this.errorCallbacks[r]=i,this.rpcTimeouts[r]=setTimeout(()=>{delete this.responseCallbacks[r],this.errorCallbacks[r]&&(this.errorCallbacks[r](null),delete this.errorCallbacks[r])},n.timeout));const o=this.serializeMessage(t,e,r);this.socket.send(o)}isReadyFlag(t){return 11===Number(t)}isPong(t){return 10===Number(t)}ping(){this.socket.send(this.isReactNative?"9":9)}toString(t){return String.fromCharCode.apply(null,new Uint16Array(t))}toBuffer(t){const e=t.length,s=new ArrayBuffer(2*e);let i=new Uint16Array(s);for(let s=0;s<e;s++)i[s]=t.charCodeAt(s);return s}}